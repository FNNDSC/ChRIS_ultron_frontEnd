<!DOCTYPE html><html><head>

    <title>iron-overlay-behavior tests</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>

    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
    <link rel="import" href="test-overlay.html">
    <link rel="import" href="test-overlay2.html">
    <link rel="import" href="test-buttons.html">
    <link rel="import" href="test-menu-button.html">

    <style is="custom-style">iron-overlay-backdrop{--iron-overlay-backdrop:{transition:none;};}</style>

  </head>

  <body>

    <test-fixture id="basic">
      <template>
        <test-overlay>
          Basic Overlay
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="opened">
      <template>
        <test-overlay opened="">
          Basic Overlay
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="autofocus">
      <template>
        <test-overlay>
          Autofocus
          <button autofocus="">button</button>
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="focusables">
      <template>
        <test-overlay tabindex="-1">
          <h2>Focusables (no tabindex)</h2>
          <div>
            <input class="focusable1" placeholder="1 (nested)">
          </div>
          <button class="focusable2">1</button>
          <button disabled=""> disabled button</button>
          <div tabindex="-1">not focusable</div>
          <button class="focusable3">2</button>
        </test-overlay>
        <test-overlay tabindex="-1">
          <h2>Focusables (with tabindex)</h2>
          <div tabindex="-1">not focusable</div>
          <div tabindex="3" class="focusable3">3</div>
          <div tabindex="4" class="focusable4">4</div>
          <div tabindex="5" class="focusable5">5</div>
          <div>
            <div tabindex="1" class="focusable1">1 (nested)</div>
            <div tabindex="6" class="focusable6">6 (nested)</div>
          </div>
          <div tabindex="2" class="focusable2">2</div>
        </test-overlay>
        <test-overlay2>
          Overlay with optimized focusableNodes getter
          <button class="focusable1">1</button>
        </test-overlay2>
      </template>
    </test-fixture>

    <test-fixture id="backdrop">
      <template>
        <test-overlay with-backdrop="">
          Overlay with backdrop
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="multiple">
      <template>
        <test-overlay class="overlay-1">
          Test overlay 1
        </test-overlay>
        <test-overlay class="overlay-2">
          Test overlay 2
        </test-overlay>
        <test-overlay2 class="overlay-3">
          Other overlay 3
        </test-overlay2>
      </template>
    </test-fixture>

    <test-fixture id="composed">
      <template>
        <test-menu-button></test-menu-button>
      </template>
    </test-fixture>

    <test-buttons id="buttons"></test-buttons>
    <input id="focusInput" placeholder="focus input">

    <script>function runAfterOpen(e,t){e.addEventListener("iron-overlay-opened",t),e.open()}function runAfterClose(e,t){e.addEventListener("iron-overlay-closed",t),e.close()}suite("basic overlay",function(){var e;setup(function(){e=fixture("basic")}),test("overlay starts hidden",function(){assert.isFalse(e.opened,"overlay starts closed"),assert.equal(getComputedStyle(e).display,"none","overlay starts hidden")}),test("_renderOpened called only after is attached",function(e){var t=document.createElement("test-overlay"),n=sinon.spy(t,"_renderOpened");t.opened=!0,t.async(function(){assert.isFalse(n.called,"_renderOpened not called"),assert.isNotOk(t._manager.currentOverlay(),"currentOverlay not set"),e()},100)}),test("overlay open/close events",function(t){var n=0;e.addEventListener("iron-overlay-opened",function(){n+=1,e.opened=!1}),e.addEventListener("iron-overlay-closed",function(){n+=1,assert.equal(n,2,"opened and closed events fired"),t()}),e.opened=!0}),test("open() refits overlay only once",function(t){var n=sinon.spy(e,"refit");runAfterOpen(e,function(){assert.equal(n.callCount,1,"overlay did refit only once"),t()})}),test("open overlay refits on iron-resize",function(t){runAfterOpen(e,function(){var n=sinon.spy(e,"refit");e.fire("iron-resize"),Polymer.dom.flush(),requestAnimationFrame(function(){assert.isTrue(n.called,"overlay did refit"),t()})})}),test("closed overlay does not refit on iron-resize",function(t){var n=sinon.spy(e,"refit");e.fire("iron-resize"),Polymer.dom.flush(),requestAnimationFrame(function(){assert.isFalse(n.called,"overlay should not refit"),t()})}),test("open() triggers iron-resize",function(t){var n=0;window.addEventListener("resize",function(){n--},!0),e.addEventListener("iron-resize",function(){n++}),runAfterOpen(e,function(){assert.equal(n,1,"iron-resize called once before iron-overlay-opened"),t()})}),test("close() triggers iron-resize",function(t){runAfterOpen(e,function(){var n=sinon.stub();e.addEventListener("iron-resize",n),runAfterClose(e,function(){assert.equal(n.callCount,1,"iron-resize called once before iron-overlay-closed"),t()})})}),test("closed overlay does not trigger iron-resize when its content changes",function(){var t=0;window.addEventListener("resize",function(){t--},!0),e.addEventListener("iron-resize",function(){t++}),Polymer.dom(e).appendChild(document.createElement("div")),Polymer.dom.flush(),assert.equal(t,0,"iron-resize should not be called")}),test("open overlay triggers iron-resize when its content changes",function(t){runAfterOpen(e,function(){var n=sinon.stub();e.addEventListener("iron-resize",n),Polymer.dom(e).appendChild(document.createElement("div")),Polymer.dom.flush(),assert.equal(n.callCount,1,"iron-resize should be called once"),t()})}),test("close an overlay quickly after open",function(t){e.open(),e.async(function(){this.close(),this.async(function(){t()},300)})}),test("clicking an overlay does not close it",function(t){runAfterOpen(e,function(){var n=sinon.stub();e.addEventListener("iron-overlay-closed",n),MockInteractions.tap(e),e.async(function(){assert.isFalse(n.called,"iron-overlay-closed should not fire"),t()},10)})}),test("open overlay on mousedown does not close it",function(t){var n=document.createElement("button");n.addEventListener("mousedown",e.open.bind(e)),document.body.appendChild(n),MockInteractions.tap(n),document.body.removeChild(n),assert.isTrue(e.opened,"overlay opened"),e.async(function(){assert.isTrue(e.opened,"overlay is still open"),t()},10)}),test("clicking outside fires iron-overlay-canceled",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-canceled",function(e){assert.equal(e.detail.target,document.body,"detail contains original click event"),t()}),MockInteractions.tap(document.body)})}),test("clicking outside closes the overlay",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-closed",function(e){assert.isTrue(e.detail.canceled,"overlay is canceled"),t()}),MockInteractions.tap(document.body)})}),test("iron-overlay-canceled event can be prevented",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-canceled",function(e){e.preventDefault()});var n=sinon.stub();e.addEventListener("iron-overlay-closed",n),MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.isTrue(e.opened,"overlay is still open"),assert.isFalse(n.called,"iron-overlay-closed not fired"),t()},10)})}),test("cancel an overlay with esc key",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-canceled",function(e){assert.equal(e.detail.type,"keydown"),t()}),MockInteractions.pressAndReleaseKeyOn(document,27)})}),test("close an overlay with esc key",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-closed",function(e){assert.isTrue(e.detail.canceled,"overlay is canceled"),t()}),MockInteractions.pressAndReleaseKeyOn(document,27)})}),test("no-cancel-on-outside-click property",function(t){e.noCancelOnOutsideClick=!0,runAfterOpen(e,function(){var n=sinon.stub();e.addEventListener("iron-overlay-closed",n),MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.isFalse(n.called,"iron-overlay-closed should not fire"),t()},10)})}),test("no-cancel-on-esc-key property",function(t){e.noCancelOnEscKey=!0,runAfterOpen(e,function(){var n=sinon.stub();e.addEventListener("iron-overlay-closed",n),MockInteractions.pressAndReleaseKeyOn(document,27),Polymer.Base.async(function(){assert.isFalse(n.called,"iron-overlay-cancel should not fire"),t()},10)})}),test("with-backdrop sets tabindex=-1 and removes it",function(){e.withBackdrop=!0,assert.equal(e.getAttribute("tabindex"),"-1","tabindex is -1"),e.withBackdrop=!1,assert.isFalse(e.hasAttribute("tabindex"),"tabindex removed")}),test("with-backdrop does not override tabindex if already set",function(){e.setAttribute("tabindex","1"),e.withBackdrop=!0,assert.equal(e.getAttribute("tabindex"),"1","tabindex is 1"),e.withBackdrop=!1,assert.equal(e.getAttribute("tabindex"),"1","tabindex is still 1")})}),suite("keyboard event listener",function(){var e,t=function(e){e.preventDefault(),e.stopPropagation()};suiteSetup(function(){document.addEventListener("keydown",t,!0)}),setup(function(){e=fixture("basic")}),suiteTeardown(function(){document.removeEventListener("keydown",t,!0)}),test("cancel an overlay with esc key even if event is prevented by other listeners",function(t){runAfterOpen(e,function(){e.addEventListener("iron-overlay-canceled",function(e){t()}),MockInteractions.pressAndReleaseKeyOn(document,27)})})}),suite("opened overlay",function(){var e;setup(function(){e=fixture("opened")}),test("overlay open by default",function(t){e.addEventListener("iron-overlay-opened",function(){assert.isTrue(e.opened,"overlay starts opened"),assert.notEqual(getComputedStyle(e).display,"none","overlay starts showing"),t()})}),test("overlay positioned & sized properly",function(t){e.addEventListener("iron-overlay-opened",function(){var n=getComputedStyle(e);assert.closeTo(parseFloat(n.left),(window.innerWidth-e.offsetWidth)/2,1,"centered horizontally"),assert.closeTo(parseFloat(n.top),(window.innerHeight-e.offsetHeight)/2,1,"centered vertically"),t()})})}),suite("focus handling",function(){var e;setup(function(){e=fixture("autofocus")}),test("node with autofocus is focused",function(t){runAfterOpen(e,function(){assert.equal(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"<button autofocus> is focused"),t()})}),test("no-auto-focus will not focus node with autofocus",function(t){e.noAutoFocus=!0,runAfterOpen(e,function(){assert.notEqual(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"<button autofocus> not focused after opened"),t()}),assert.notEqual(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"<button autofocus> not immediately focused")}),test("no-cancel-on-outside-click property; focus stays on overlay when click outside",function(t){e.noCancelOnOutsideClick=!0,runAfterOpen(e,function(){MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.equal(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"<button autofocus> is focused"),t()},10)})}),test("with-backdrop traps the focus within the overlay",function(t){var n=sinon.stub(),o=document.createElement("button");document.body.appendChild(o),o.addEventListener("focus",n,!0),e.withBackdrop=!0,runAfterOpen(e,function(){MockInteractions.focus(o),assert.equal(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"<button autofocus> is focused"),assert.equal(n.callCount,0,"button in body did not get the focus"),document.body.removeChild(o),t()})}),test("overlay with-backdrop and 1 focusable: prevent TAB and trap the focus",function(t){e.withBackdrop=!0,runAfterOpen(e,function(){Polymer.Base.async(function(){var n=sinon.spy();document.addEventListener("keydown",n),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(Polymer.dom(e).querySelector("[autofocus]"),document.activeElement,"focus stays on button"),assert.isTrue(n.calledOnce,"keydown spy called"),assert.isTrue(n.getCall(0).args[0].defaultPrevented,"keydown default prevented"),document.removeEventListener("keydown",n),t()},1)})}),test("empty overlay with-backdrop: prevent TAB and trap the focus",function(t){e=fixture("basic"),e.withBackdrop=!0,runAfterOpen(e,function(){Polymer.Base.async(function(){var n=sinon.spy();document.addEventListener("keydown",n),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(e,document.activeElement,"focus stays on overlay"),assert.isTrue(n.calledOnce,"keydown spy called"),assert.isTrue(n.getCall(0).args[0].defaultPrevented,"keydown default prevented"),document.removeEventListener("keydown",n),t()},1)})})}),suite("focusable nodes",function(){var e,t,n;setup(function(){var o=fixture("focusables");e=o[0],t=o[1],n=o[2]}),test("_focusableNodes returns nodes that are focusable",function(){var t=e._focusableNodes;assert.equal(t.length,3,"3 nodes are focusable"),assert.equal(t[0],Polymer.dom(e).querySelector(".focusable1")),assert.equal(t[1],Polymer.dom(e).querySelector(".focusable2")),assert.equal(t[2],Polymer.dom(e).querySelector(".focusable3"))}),test("_focusableNodes includes overlay if it has a valid tabindex",function(){e.setAttribute("tabindex","0");var t=e._focusableNodes;assert.equal(t.length,4,"4 focusable nodes"),assert.notEqual(t.indexOf(e),-1,"overlay is included")}),test("_focusableNodes respects the tabindex order",function(){var e=t._focusableNodes;assert.equal(e.length,6,"6 nodes are focusable"),assert.equal(e[0],Polymer.dom(t).querySelector(".focusable1")),assert.equal(e[1],Polymer.dom(t).querySelector(".focusable2")),assert.equal(e[2],Polymer.dom(t).querySelector(".focusable3")),assert.equal(e[3],Polymer.dom(t).querySelector(".focusable4")),assert.equal(e[4],Polymer.dom(t).querySelector(".focusable5")),assert.equal(e[5],Polymer.dom(t).querySelector(".focusable6"))}),test("_focusableNodes can be overridden",function(){var e=n._focusableNodes;assert.equal(e.length,2,"length ok"),assert.equal(e[0],n.$.first,"first ok"),assert.equal(e[1],n.$.last,"last ok")}),test("with-backdrop: TAB & Shift+TAB wrap focus",function(t){e.withBackdrop=!0;var n=e._focusableNodes;runAfterOpen(e,function(){Polymer.Base.async(function(){n[n.length-1].focus();var e=sinon.spy();document.addEventListener("keydown",e),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(n[0],document.activeElement,"focus wrapped to first focusable"),assert.isTrue(e.calledOnce,"keydown spy called"),assert.isTrue(e.getCall(0).args[0].defaultPrevented,"keydown default prevented"),MockInteractions.pressAndReleaseKeyOn(document,9,["shift"]),assert.equal(n[n.length-1],document.activeElement,"focus wrapped to last focusable"),assert.isTrue(e.calledTwice,"keydown spy called again"),assert.isTrue(e.getCall(1).args[0].defaultPrevented,"keydown default prevented again"),document.removeEventListener("keydown",e),t()},1)})}),test("with-backdrop: TAB & Shift+TAB wrap focus respecting tabindex",function(e){t.withBackdrop=!0;var n=t._focusableNodes;runAfterOpen(t,function(){Polymer.Base.async(function(){n[n.length-1].focus(),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(n[0],document.activeElement,"focus wrapped to first focusable"),MockInteractions.pressAndReleaseKeyOn(document,9,["shift"]),assert.equal(n[n.length-1],document.activeElement,"focus wrapped to last focusable"),e()},1)})}),test("with-backdrop: Shift+TAB after open wrap focus",function(t){e.withBackdrop=!0;var n=e._focusableNodes;runAfterOpen(e,function(){Polymer.Base.async(function(){var e=sinon.spy();document.addEventListener("keydown",e),MockInteractions.pressAndReleaseKeyOn(document,9,["shift"]),assert.equal(n[n.length-1],document.activeElement,"focus wrapped to last focusable"),assert.isTrue(e.calledOnce,"keydown spy called"),assert.isTrue(e.getCall(0).args[0].defaultPrevented,"keydown default prevented"),document.removeEventListener("keydown",e),t()},1)})}),test("with-backdrop: Shift+TAB wrap focus in shadowDOM",function(e){n.withBackdrop=!0,runAfterOpen(n,function(){Polymer.Base.async(function(){var t=sinon.spy();document.addEventListener("keydown",t),MockInteractions.pressAndReleaseKeyOn(document,9,["shift"]),assert.equal(n.$.last,Polymer.IronOverlayManager.deepActiveElement,"focus wrapped to last focusable in the shadowDOM"),assert.isTrue(t.calledOnce,"keydown spy called"),assert.isTrue(t.getCall(0).args[0].defaultPrevented,"keydown default prevented"),document.removeEventListener("keydown",t),e()},1)})})}),suite("Polymer.IronOverlayManager.deepActiveElement",function(){test("handles document.body",function(){document.body.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,document.body)}),test("handles light dom",function(){var e=document.getElementById("focusInput");e.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,e,"input is handled"),e.blur()}),test("handles shadow dom",function(){var e=document.getElementById("buttons").$.button0;e.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,e),e.blur()})}),suite("restore-focus-on-close",function(){var e;setup(function(){e=fixture("autofocus"),e.restoreFocusOnClose=!0}),teardown(function(){document.body.focus()}),test("does not return focus on close by default (restore-focus-on-close=false)",function(t){e.restoreFocusOnClose=!1;var n=document.getElementById("focusInput");n.focus(),runAfterOpen(e,function(){runAfterClose(e,function(){assert.notEqual(Polymer.IronOverlayManager.deepActiveElement,n,"focus is not restored to focusable"),t()})})}),test("overlay returns focus on close",function(t){var n=document.getElementById("focusInput");n.focus(),runAfterOpen(e,function(){runAfterClose(e,function(){assert.equal(Polymer.IronOverlayManager.deepActiveElement,n,"focus restored to focusable"),t()})})}),test("overlay returns focus on close (ShadowDOM)",function(t){var n=document.getElementById("buttons").$.button0;n.focus(),runAfterOpen(e,function(){runAfterClose(e,function(){assert.equal(Polymer.IronOverlayManager.deepActiveElement,n,"focus restored to focusable"),t()})})}),test("overlay does not return focus to elements contained in another overlay",function(t){var n=fixture("basic");n.noAutoFocus=!0;var o=document.createElement("input");runAfterOpen(n,function(){Polymer.dom(n).appendChild(o),o.focus(),runAfterOpen(e,function(){runAfterClose(e,function(){assert.notEqual(Polymer.IronOverlayManager.deepActiveElement,o,"focus not restored to focusable inside overlay2"),t()})})})}),test("overlay does not return focus to elements that are not in the body anymore",function(t){var n=document.createElement("input");document.body.appendChild(n),n.focus();var o=sinon.spy(n,"focus");runAfterOpen(e,function(){document.body.removeChild(n),runAfterClose(e,function(){assert.isFalse(o.called,"focus not called"),t()})})})}),suite("overlay with backdrop",function(){var e;setup(function(){e=fixture("backdrop")}),test("backdrop is opened when overlay is opened",function(t){assert.isOk(e.backdropElement,"backdrop is defined"),runAfterOpen(e,function(){assert.isTrue(e.backdropElement.opened,"backdrop is opened"),assert.isOk(e.backdropElement.parentNode,"backdrop is inserted in the DOM"),t()})}),test("backdrop appears behind the overlay",function(t){runAfterOpen(e,function(){styleZ=parseInt(window.getComputedStyle(e).zIndex,10),backdropStyleZ=parseInt(window.getComputedStyle(e.backdropElement).zIndex,10),assert.isTrue(styleZ>backdropStyleZ,"overlay has higher z-index than backdrop"),t()})}),test("backdrop is removed when overlay is closed",function(t){runAfterOpen(e,function(){runAfterClose(e,function(){assert.isFalse(e.backdropElement.opened,"backdrop is closed"),assert.isNotOk(e.backdropElement.parentNode,"backdrop is removed from the DOM"),assert.lengthOf(document.querySelectorAll("iron-overlay-backdrop"),0,"no backdrop elements on body"),t()})})}),test("backdrop is removed when the element is removed from DOM",function(t){runAfterOpen(e,function(){Polymer.dom(e).parentNode.removeChild(e),Polymer.dom.flush(),assert.isFalse(e.backdropElement.opened,"backdrop is closed"),assert.isNotOk(e.backdropElement.parentNode,"backdrop is removed from the DOM"),assert.lengthOf(document.querySelectorAll("iron-overlay-backdrop"),0,"no backdrop elements on body"),assert.isNotOk(e._manager.currentOverlay(),"currentOverlay ok"),t()})}),test("manager.getBackdrops() updated on opened changes",function(t){runAfterOpen(e,function(){assert.equal(Polymer.IronOverlayManager.getBackdrops().length,1,"overlay added to manager backdrops"),e.close(),assert.equal(Polymer.IronOverlayManager.getBackdrops().length,0,"overlay removed from manager backdrops"),t()})}),test("updating with-backdrop to false closes backdrop",function(t){runAfterOpen(e,function(){e.withBackdrop=!1,assert.isFalse(e.backdropElement.opened,"backdrop is closed"),assert.isNotObject(e.backdropElement.parentNode,"backdrop is removed from document"),t()})}),test("backdrop is removed when toggling overlay opened",function(t){e.open(),runAfterClose(e,function(){assert.isFalse(e.backdropElement.opened,"backdrop is closed"),assert.isNotOk(e.backdropElement.parentNode,"backdrop is removed from document"),t()})}),test("withBackdrop = false does not prevent click outside event",function(t){e.withBackdrop=!1,runAfterOpen(e,function(){e.addEventListener("iron-overlay-canceled",function(e){assert.isFalse(e.detail.defaultPrevented,"click event not prevented"),t()}),MockInteractions.tap(document.body)})})}),suite("multiple overlays",function(){var e,t;setup(function(){var n=fixture("multiple");e=n[0],t=n[1]}),test("new overlays appear on top",function(n){runAfterOpen(e,function(){runAfterOpen(t,function(){var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10);assert.isTrue(r>o,"overlay2 has higher z-index than overlay1"),n()})})}),test("ESC closes only the top overlay",function(n){runAfterOpen(e,function(){runAfterOpen(t,function(){MockInteractions.pressAndReleaseKeyOn(document,27),assert.isFalse(t.opened,"overlay2 was closed"),assert.isTrue(e.opened,"overlay1 is still opened"),n()})})}),test("close an overlay in proximity to another overlay",function(n){e.open(),e.close(),t.open(),runAfterClose(t,function(){n()})})}),suite("Manager overlays in sync",function(){var e,t,n;setup(function(){var o=fixture("multiple");e=o[0],t=o[1],n=Polymer.IronOverlayManager._overlays}),test("no duplicates after attached",function(t){e=document.createElement("test-overlay"),runAfterOpen(e,function(){assert.equal(n.length,1,"correct count after open and attached"),document.body.removeChild(e),t()}),document.body.appendChild(e)}),test("call open multiple times handled",function(t){e.open(),e.open(),runAfterOpen(e,function(){assert.equal(n.length,1,"1 overlay after open"),t()})}),test("close handled",function(t){runAfterOpen(e,function(){e.close(),assert.equal(n.length,0,"0 overlays after close"),t()})}),test("open/close brings overlay on top",function(o){e.open(),runAfterOpen(t,function(){assert.equal(n.indexOf(e),0,"overlay1 at index 0"),assert.equal(n.indexOf(t),1,"overlay2 at index 1"),e.close(),runAfterOpen(e,function(){assert.equal(n.indexOf(e),1,"overlay1 moved at index 1"),assert.isAbove(parseInt(e.style.zIndex),parseInt(t.style.zIndex),"overlay1 on top of overlay2"),o()})})})}),suite("z-ordering",function(){var e,t,n;setup(function(){var o=fixture("multiple");t=o[0],n=o[1],e=Polymer.IronOverlayManager._minimumZ}),teardown(function(){Polymer.IronOverlayManager._minimumZ=e}),test("default z-index is greater than 100",function(e){runAfterOpen(t,function(){var n=parseInt(window.getComputedStyle(t).zIndex,10);assert.isTrue(n>100,"overlay1 z-index is <= 100"),e()})}),test("ensureMinimumZ() effects z-index",function(e){Polymer.IronOverlayManager.ensureMinimumZ(1e3),runAfterOpen(t,function(){var n=parseInt(window.getComputedStyle(t).zIndex,10);assert.isTrue(n>1e3,"overlay1 z-index is <= 1000"),e()})}),test("ensureMinimumZ() never decreases the minimum z-index",function(e){Polymer.IronOverlayManager.ensureMinimumZ(1e3),Polymer.IronOverlayManager.ensureMinimumZ(500),runAfterOpen(t,function(){var n=parseInt(window.getComputedStyle(t).zIndex,10);assert.isTrue(n>1e3,"overlay1 z-index is <= 1000"),e()})})}),suite("multiple overlays with backdrop",function(){var e,t,n;setup(function(){var o=fixture("multiple");e=o[0],t=o[1],n=o[2],e.withBackdrop=t.withBackdrop=n.withBackdrop=!0}),test("multiple overlays share the same backdrop",function(){assert.isTrue(e.backdropElement===t.backdropElement,"overlay1 and overlay2 have the same backdrop element"),assert.isTrue(e.backdropElement===n.backdropElement,"overlay1 and overlay3 have the same backdrop element")}),test("only one iron-overlay-backdrop in the DOM",function(o){e.opened=!0,t.opened=!0,runAfterOpen(n,function(){assert.lengthOf(document.querySelectorAll("iron-overlay-backdrop"),1,"only one backdrop element in the DOM"),o()})}),test("iron-overlay-backdrop is removed from the DOM when all overlays with backdrop are closed",function(o){e.opened=!0,t.opened=!0,runAfterOpen(n,function(){e.opened=t.opened=n.opened=!1,Polymer.dom.flush(),assert.lengthOf(document.querySelectorAll("iron-overlay-backdrop"),0,"backdrop element removed from the DOM"),o()})}),test("newest overlay appear on top",function(n){runAfterOpen(e,function(){runAfterOpen(t,function(){var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10),a=parseInt(window.getComputedStyle(e.backdropElement).zIndex,10);assert.isTrue(r>o,"overlay2 has higher z-index than overlay1"),assert.isTrue(o>a,"overlay1 has higher z-index than backdrop"),n()})})}),test("click events handled only by top overlay",function(n){var o=document.createElement("button");o.addEventListener("tap",t.close.bind(t)),Polymer.dom(t).appendChild(o),runAfterOpen(e,function(){runAfterOpen(t,function(){MockInteractions.tap(o),assert.isFalse(t.opened,"overlay2 closed"),assert.isTrue(e.opened,"overlay1 still opened"),n()})})}),test("updating with-backdrop updates z-index",function(n){runAfterOpen(e,function(){runAfterOpen(t,function(){e.withBackdrop=!1;var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10),a=parseInt(window.getComputedStyle(e.backdropElement).zIndex,10);assert.isTrue(r>a,"overlay2 has higher z-index than backdrop"),assert.isTrue(a>o,"overlay1 has lower z-index than backdrop"),n()})})})}),suite("overlay in composed tree",function(){var e,t,n;setup(function(o){e=fixture("composed"),t=e.$.overlay,n=e.$.trigger,t.withBackdrop=!0,t.addEventListener("iron-overlay-opened",function(){o()}),MockInteractions.tap(n)}),test("click on overlay content does not close it",function(e){MockInteractions.tap(Polymer.dom(t).querySelector("button")),Polymer.Base.async(function(){assert.isTrue(t.opened,"overlay still opened"),e()},1)}),test("with-backdrop wraps the focus within the overlay",function(e){Polymer.Base.async(function(){var n=Polymer.dom(t).querySelectorAll("button");n[n.length-1].focus();var o=sinon.spy();document.addEventListener("keydown",o),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(n[0],Polymer.IronOverlayManager.deepActiveElement,"focus wrapped to first focusable"),assert.isTrue(o.calledOnce,"keydown spy called"),assert.isTrue(o.getCall(0).args[0].defaultPrevented,"keydown default prevented"),MockInteractions.pressAndReleaseKeyOn(document,9,["shift"]),assert.equal(n[n.length-1],Polymer.IronOverlayManager.deepActiveElement,"focus wrapped to last focusable"),assert.isTrue(o.calledTwice,"keydown spy called again"),assert.isTrue(o.getCall(1).args[0].defaultPrevented,"keydown default prevented again"),document.removeEventListener("keydown",o),e()},1)})}),suite("always-on-top",function(){var e,t;setup(function(){var n=fixture("multiple");e=n[0],t=n[1],e.alwaysOnTop=!0}),test("stays on top",function(n){runAfterOpen(e,function(){runAfterOpen(t,function(){var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10);assert.isAbove(o,r,"overlay1 on top"),assert.equal(Polymer.IronOverlayManager.currentOverlay(),e,"currentOverlay ok"),n()})})}),test("stays on top also if another overlay is with-backdrop",function(n){t.withBackdrop=!0,runAfterOpen(e,function(){runAfterOpen(t,function(){var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10);assert.isAbove(o,r,"overlay1 on top"),assert.equal(Polymer.IronOverlayManager.currentOverlay(),e,"currentOverlay ok"),n()})})}),test("last overlay with always-on-top wins",function(n){t.alwaysOnTop=!0,runAfterOpen(e,function(){runAfterOpen(t,function(){var o=parseInt(window.getComputedStyle(e).zIndex,10),r=parseInt(window.getComputedStyle(t).zIndex,10);assert.isAbove(r,o,"overlay2 on top"),assert.equal(Polymer.IronOverlayManager.currentOverlay(),t,"currentOverlay ok"),n()})})})}),suite("animations",function(){test("overlay animations correctly triggered",function(e){var t=fixture("basic");t.animated=!0,t.open(),t.addEventListener("simple-overlay-open-animation-start",function(){var n=document.elementFromPoint(window.innerWidth/2,window.innerHeight/2);assert.notEqual(n,t,"overlay should not be centered already"),e()})})}),suite("a11y",function(){test("overlay has aria-hidden=true when opened",function(){var e=fixture("basic");assert.equal(e.getAttribute("aria-hidden"),"true",'overlay has aria-hidden="true"'),e.open(),assert.isFalse(e.hasAttribute("aria-hidden"),"overlay does not have aria-hidden attribute"),e.close(),assert.equal(e.getAttribute("aria-hidden"),"true",'overlay has aria-hidden="true"')})});</script>

  


</body></html>