<!--
@license
Copyright (c) 2016 FNNDSC. All rights reserved.
-->

<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../chris-plugin-tree-recursive/chris-plugin-tree-recursive.html">

<dom-module id="chris-plugin-tree">

  <template>

    <style>

      :host {

        display: block;

        }

      .plugin, .label, .children {

        display: flex;

      }

      .plugin {

        flex-direction: column

      }

      .children {

        flex-direction: row

      }

      .label {

        height: 50px;
        color: red;
        justify-content: center;

      }

    </style>

    <chris-plugin-tree-recursive id="test" tree="{{tree}}" on-select-node="_selectNode"></chris-plugin-tree-recursive>

  </template>

  <script>
    Polymer({
        is: 'chris-plugin-tree',

        properties: {

          list: {
            type: Array
          },

          tree: {
            type: Array,
            observer: '_treeChanged'
          },

          selected: {
            type: Object,
            observer: '_selectedChanged'
          }
        },

        observers: [
          '_listChanged(list.*)',
          '_treeChanged(tree.splices)'
        ],

        _listChanged: function(){

          console.log(this.list);

          this._build( this.list );

          // select deepest element
          var list = this.list;
          list.sort( this._sortByPathLength );
          this.selected = list[0];


          //
          // update list and tree
          this._selectedChanged();

        },

        _treeChanged: function(){

          // console.log( this.tree );

        },

        _build: function( list ){

          console.log(list);

          // sort by previous id
          list.sort( this._sortByPreviousId );

          // note
          // path required so polymer auto binding kick in
          var tree = [];
          var map = {};
          var treePath = [];
          for(var i = 0; i < list.length; i++ ){

            var node = list[i];
            node.data.children = [];
            map[node.data.id] = i;

            if(node.data.previous_id === null || node.data.previous_id === '') {
              node.data.path = ['tree', 0, 'data'];
              tree.push( node );
            }
            else{
              var previousPath = list[map[node.data.previous_id]].data.path;
              node.data.path = previousPath.concat( ['children', list[map[node.data.previous_id]].data.children.length, 'data'] );
              list[map[node.data.previous_id]].data.children.push(node);
            }

          }

          this.set('tree', tree);
          this.fire('tree-changed', this.tree);

        },

        _find: function( nodeID ){

        },

        _insert: function( parentID, nodeID){

        },

        _flatten: function(){
          //
        },

        _sortByPreviousId: function( a, b ){

            // special case for the root
            if(a.data.previous_id === '' ||  a.data.previous_id === null) {
              return -1;
            }
            if(b.data.previous_id === '' || b.data.previous_id === null) {
              return 1;
            }

            if(parseInt(a.data.previous_id, 10) > parseInt(b.data.previous_id, 10)) {
              return 1;
            }
            if(parseInt(a.data.previous_id, 10) < parseInt(b.data.previous_id, 10)) {
              return -1;
            }
            // a must be equal to b
            return 0;

        },

        _sortByPathLength: function( a, b ){

            if ( a.data.path.length < b.data.path.length ) {
              return 1;
            }
            if ( a.data.path.length > b.data.path.length ) {
              return -1;
            }
            // a must be equal to b
            return 0;

        },

        _selectNode: function( event ){

          // stop event propagation
          event.preventDefault();
          event.stopPropagation();

          this.selected = event.detail;

        },

        _selectedChanged: function(){

          console.log('selected changed');

          var selectedId = -1;

          if( this.selected && this.selected.data && this.selected.data.id ){

            selectedId = this.selected.data.id

          }

          //
          //
          // MAGICS
          //
          //

          // update list and tree

                      console.log('selected changed');

          this.list.map(function(obj){

            console.log(obj);
            console.log(obj.data.selected);
            console.log(obj.data.status);

            obj.data.selected = (obj.data.id === selectedId);
            // required so polymer auto bindings kick in
            this.set(obj.data.path.concat(['selected']), obj.data.selected );
            this.set(obj.data.path.concat(['status']), obj.data.status );

          }.bind(this));

          // fire event!
          this.fire( 'select-node', this.selected );

        },

    });
  </script>
</dom-module>
